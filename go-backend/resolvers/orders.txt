package resolvers

import (
	"context"
	"fmt"
	"go-backend/db"
	"go-backend/models"
	"strconv"

	"github.com/graph-gophers/graphql-go"
)

func (r *Resolver) Orders(ctx context.Context) ([]*OrderResolver, error) {
	rows, err := db.DB.Query("SELECT id, user_id, total_amount, status, created_at FROM orders")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var orders []*OrderResolver
	for rows.Next() {
		var o models.Order
		if err := rows.Scan(&o.ID, &o.UserID, &o.TotalAmount, &o.Status, &o.CreatedAt); err != nil {
			return nil, err
		}
		orders = append(orders, &OrderResolver{o})
	}

	return orders, nil
}

func (r *Resolver) Order(ctx context.Context, args struct{ ID graphql.ID }) (*OrderResolver, error) {
	id, err := strconv.Atoi(string(args.ID))
	if err != nil {
		return nil, fmt.Errorf("invalid ID: %v", err)
	}
	var o models.Order
	err = db.DB.QueryRow("SELECT id, user_id, total_amount, status, created_at FROM orders WHERE id = $1", id).Scan(&o.ID, &o.UserID, &o.TotalAmount, &o.Status, &o.CreatedAt)
	if err != nil {
		return nil, err
	}
	return &OrderResolver{o}, nil
}

func (r *Resolver) CreateOrder(ctx context.Context, args struct{ Input models.OrderInput }) (*OrderResolver, error) {
	tx, err := db.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	var orderID int
	err = tx.QueryRow(`
        INSERT INTO orders (user_id, total_amount, status, created_at)
        VALUES ($1, $2, 'Pending', NOW())
        RETURNING id
    `, args.Input.UserID, 0).Scan(&orderID)
	if err != nil {
		return nil, err
	}

	totalAmount := 0.0
	for _, item := range args.Input.Items {
		var priceAtTime float64
		err = tx.QueryRow(`
            SELECT price FROM products WHERE id = $1
        `, item.ProductID).Scan(&priceAtTime)
		if err != nil {
			return nil, err
		}

		_, err = tx.Exec(`
            INSERT INTO order_items (order_id, product_id, quantity, price_at_time)
            VALUES ($1, $2, $3, $4)
        `, orderID, item.ProductID, item.Quantity, priceAtTime)
		if err != nil {
			return nil, err
		}

		totalAmount += priceAtTime * float64(item.Quantity)
	}

	_, err = tx.Exec(`UPDATE orders SET total_amount = $1 WHERE id = $2`, totalAmount, orderID)
	if err != nil {
		return nil, err
	}

	if err = tx.Commit(); err != nil {
		return nil, err
	}

	var o models.Order
	err = db.DB.QueryRow(`
        SELECT id, user_id, total_amount, status, created_at
        FROM orders WHERE id = $1
    `, orderID).Scan(&o.ID, &o.UserID, &o.TotalAmount, &o.Status, &o.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &OrderResolver{o}, nil
}

func (r *Resolver) UserOrders(ctx context.Context, args struct{ UserID graphql.ID }) ([]*OrderResolver, error) {
	userID, err := strconv.Atoi(string(args.UserID))
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %v", err)
	}

	rows, err := db.DB.Query("SELECT id, user_id, total_amount, status, created_at FROM orders WHERE user_id = $1", userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var orders []*OrderResolver
	for rows.Next() {
		var o models.Order
		if err := rows.Scan(&o.ID, &o.UserID, &o.TotalAmount, &o.Status, &o.CreatedAt); err != nil {
			return nil, err
		}
		orders = append(orders, &OrderResolver{o})
	}

	return orders, nil
}

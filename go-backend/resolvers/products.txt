package resolvers

import (
	"context"
	"database/sql"
	"go-backend/db"
	"go-backend/models"

	"github.com/graph-gophers/graphql-go"
)

func (r *Resolver) Product(ctx context.Context, args struct{ ID graphql.ID }) (*ProductResolver, error) {
	var p models.Product
	err := db.DB.QueryRow("SELECT id, name, description, price, stock_quantity, category_id FROM products WHERE id = $1", args.ID).Scan(&p.ID, &p.Name, &p.Description, &p.Price, &p.StockQuantity, &p.CategoryID)
	if err != nil {
		return nil, err
	}
	return &ProductResolver{p}, nil
}

func (r *Resolver) Products(ctx context.Context, args struct{ Category, Search *string }) ([]*ProductResolver, error) {
	var rows *sql.Rows
	var err error

	if args.Category != nil {
		rows, err = db.DB.Query("SELECT id, name, description, price, stock_quantity, category_id FROM products WHERE category_id = $1", *args.Category)
	} else if args.Search != nil {
		searchPattern := "%" + *args.Search + "%"
		rows, err = db.DB.Query("SELECT id, name, description, price, stock_quantity, category_id FROM products WHERE name ILIKE $1", searchPattern)
	} else {
		rows, err = db.DB.Query("SELECT id, name, description, price, stock_quantity, category_id FROM products")
	}

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var products []*ProductResolver
	for rows.Next() {
		var p models.Product
		if err := rows.Scan(&p.ID, &p.Name, &p.Description, &p.Price, &p.StockQuantity, &p.CategoryID); err != nil {
			return nil, err
		}
		products = append(products, &ProductResolver{p})
	}

	return products, nil
}

func (r *Resolver) CreateProduct(ctx context.Context, args struct{ Input models.ProductInput }) (*ProductResolver, error) {
	tx, err := db.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	var productID int
	err = tx.QueryRow(`
        INSERT INTO products (name, description, price, stock_quantity, category_id)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
    `, args.Input.Name, args.Input.Description, args.Input.Price, args.Input.StockQuantity, args.Input.CategoryID).Scan(&productID)
	if err != nil {
		return nil, err
	}

	if err = tx.Commit(); err != nil {
		return nil, err
	}

	var p models.Product
	err = db.DB.QueryRow(`
        SELECT id, name, description, price, stock_quantity, category_id
        FROM products WHERE id = $1
    `, productID).Scan(&p.ID, &p.Name, &p.Description, &p.Price, &p.StockQuantity, &p.CategoryID)
	if err != nil {
		return nil, err
	}

	return &ProductResolver{p}, nil
}

func (r *Resolver) UpdateProduct(ctx context.Context, args struct {
	ID    int
	Input models.ProductInput
}) (*ProductResolver, error) {
	tx, err := db.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	_, err = tx.Exec(`
        UPDATE products
        SET name = $1, description = $2, price = $3, stock_quantity = $4, category_id = $5
        WHERE id = $6
    `, args.Input.Name, args.Input.Description, args.Input.Price, args.Input.StockQuantity, args.Input.CategoryID, args.ID)
	if err != nil {
		return nil, err
	}

	if err = tx.Commit(); err != nil {
		return nil, err
	}

	var p models.Product
	err = db.DB.QueryRow(`
        SELECT id, name, description, price, stock_quantity, category_id
        FROM products WHERE id = $1
    `, args.ID).Scan(&p.ID, &p.Name, &p.Description, &p.Price, &p.StockQuantity, &p.CategoryID)
	if err != nil {
		return nil, err
	}

	return &ProductResolver{p}, nil
}
